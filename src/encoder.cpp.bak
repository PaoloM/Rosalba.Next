#include "encoder.h"
#include "display.h"
#include "obd.h"

// Global encoder instance
RotaryEncoder encoder;

// Menu system state management
bool inSettingsSubmenu = false;
unsigned long lastMenuUpdate = 0;
const unsigned long MENU_UPDATE_INTERVAL = 100; // Update menu every 100ms

// Handle all encoder input
void processEncoderInput() {
    EncoderDirection rotation = encoder.checkRotation();
    bool buttonPress = encoder.checkButtonPress();
    
    unsigned long currentTime = millis();
    
    // Only process if enough time has passed (debouncing)
    if (currentTime - lastMenuUpdate < MENU_UPDATE_INTERVAL) {
        return;
    }
    
    // Handle rotation
    if (rotation != ENCODER_NO_CHANGE) {
        if (inSettingsSubmenu) {
            // In settings submenu - adjust current setting
            encoder.handleSettingsAdjustment(rotation);
            updateDisplayBrightness(); // Apply brightness immediately
        } else {
            // In main menu navigation
            encoder.handleMenuNavigation(rotation);
            updateDisplayForCurrentMenu();
        }
        lastMenuUpdate = currentTime;
    }
    
    // Handle button press
    if (buttonPress) {
        handleButtonPress();
        lastMenuUpdate = currentTime;
    }
}

// Handle button press based on current menu
void handleButtonPress() {
    switch (encoder.currentMenu) {
        case MENU_MAIN_DASHBOARD:
            // Toggle display mode (gauges/numbers/graph)
            encoder.handleDisplayModeToggle();
            updateDisplayForCurrentMenu();
            break;
            
        case MENU_PERFORMANCE:
            // Start/stop performance logging
            togglePerformanceMode();
            break;
            
        case MENU_DIAGNOSTICS:
            // Refresh diagnostic data
            refreshDiagnosticData();
            break;
            
        case MENU_DATA_LOGS:
            // Export current session data
            exportCurrentSession();
            break;
            
        case MENU_SETTINGS:
            // Enter/exit settings submenu
            toggleSettingsSubmenu();
            break;
    }
}

// Toggle between settings navigation and adjustment
void toggleSettingsSubmenu() {
    inSettingsSubmenu = !inSettingsSubmenu;
    
    if (inSettingsSubmenu) {
        Serial.println("üîß Entered settings adjustment mode");
        Serial.print("Adjusting: ");
        Serial.println(getSettingName(encoder.currentSetting));
    } else {
        // Move to next setting
        encoder.currentSetting = (SettingsOption)((encoder.currentSetting + 1) % SETTINGS_COUNT);
        Serial.println("‚öôÔ∏è Settings navigation mode");
        Serial.print("Selected: ");
        Serial.println(getSettingName(encoder.currentSetting));
    }
}

// Update display based on current menu and mode
void updateDisplayForCurrentMenu() {
    tft.fillScreen(TFT_BLACK);
    
    switch (encoder.currentMenu) {
        case MENU_MAIN_DASHBOARD:
            drawMainDashboard();
            break;
            
        case MENU_PERFORMANCE:
            drawPerformanceScreen();
            break;
            
        case MENU_DIAGNOSTICS:
            drawDiagnosticsScreen();
            break;
            
        case MENU_DATA_LOGS:
            drawDataLogsScreen();
            break;
            
        case MENU_SETTINGS:
            drawSettingsScreen();
            break;
    }
    
    // Draw menu indicator at top
    drawMenuIndicator();
}

// Draw main dashboard based on current display mode
void drawMainDashboard() {
    switch (encoder.currentDisplayMode) {
        case DISPLAY_GAUGES:
            // Draw circular gauges for RPM and boost
            drawCircularGauge(60, 120, 50, vehicle.rpm, 0, 7000, "RPM", TFT_RED);
            drawCircularGauge(240, 120, 50, vehicle.boostPressure, 0, 25, "BOOST", TFT_YELLOW);
            drawCircularGauge(420, 120, 50, vehicle.speed, 0, 200, "KM/H", TFT_GREEN);
            break;
            
        case DISPLAY_NUMBERS:
            // Large digital readouts
            tft.setTextSize(3);
            drawParameter("RPM", String((int)vehicle.rpm), 10, 50, 3, TFT_RED);
            drawParameter("BOOST", String(vehicle.boostPressure, 1) + " PSI", 10, 120, 3, TFT_YELLOW);
            drawParameter("SPEED", String((int)vehicle.speed) + " KM/H", 10, 190, 3, TFT_GREEN);
            break;
            
        case DISPLAY_GRAPH:
            // Real-time graph of boost vs RPM
            drawRealtimeGraph();
            break;
    }
}

// Draw performance screen
void drawPerformanceScreen() {
    tft.setTextSize(2);
    tft.setTextColor(TFT_WHITE);
    tft.drawString("üèÅ PERFORMANCE MODE", 10, 10);
    
    // Show 0-60 time if available
    if (perfMetrics.zeroToSixty > 0) {
        drawParameter("0-60 mph", String(perfMetrics.zeroToSixty, 2) + "s", 10, 50, 2, TFT_CYAN);
    } else {
        tft.drawString("Waiting for 0-60 run...", 10, 50);
    }
    
    drawParameter("Max Boost", String(perfMetrics.maxBoost, 1) + " PSI", 10, 100, 2, TFT_YELLOW);
    drawParameter("Peak RPM", String((int)vehicle.rpm), 10, 150, 2, TFT_RED);
}

// Draw diagnostics screen
void drawDiagnosticsScreen() {
    tft.setTextSize(2);
    tft.setTextColor(TFT_WHITE);
    tft.drawString("üîß DIAGNOSTICS", 10, 10);
    
    // Show system status
    drawParameter("CAN Bus", "OK", 10, 50, 2, TFT_GREEN);
    drawParameter("Display", "OK", 10, 80, 2, TFT_GREEN);
    drawParameter("SD Card", sdCard.initialized ? "OK" : "FAIL", 10, 110, 2, 
                 sdCard.initialized ? TFT_GREEN : TFT_RED);
    
    // Show current vehicle data age
    drawParameter("Data Age", String(millis() - lastOBDResponse) + "ms", 10, 140, 2, TFT_CYAN);
}

// Draw data logs screen
void drawDataLogsScreen() {
    tft.setTextSize(2);
    tft.setTextColor(TFT_WHITE);
    tft.drawString("üìä DATA LOGS", 10, 10);
    
    if (sdCard.initialized) {
        tft.drawString(sdCard.getCardInfo(), 10, 50);
        tft.drawString("Current: " + sdCard.currentLogFile, 10, 80);
        tft.drawString("Press to export session", 10, 140);
    } else {
        tft.drawString("No SD Card detected", 10, 50);
    }
}

// Draw settings screen
void drawSettingsScreen() {
    tft.setTextSize(2);
    tft.setTextColor(TFT_WHITE);
    tft.drawString("‚öôÔ∏è SETTINGS", 10, 10);
    
    // Highlight current setting
    int yPos = 50;
    for (int i = 0; i < SETTINGS_COUNT; i++) {
        uint16_t color = (i == encoder.currentSetting) ? TFT_YELLOW : TFT_WHITE;
        if (inSettingsSubmenu && i == encoder.currentSetting) {
            color = TFT_CYAN; // Bright color when adjusting
        }
        
        tft.setTextColor(color);
        tft.drawString(getSettingDisplayText((SettingsOption)i), 10, yPos);
        yPos += 30;
    }
    
    // Instructions
    tft.setTextColor(TFT_GREEN);
    tft.setTextSize(1);
    tft.drawString(inSettingsSubmenu ? "Rotate: Adjust | Press: Next" : "Rotate: Navigate | Press: Edit", 10, 200);
}

// Apply brightness setting to display
void updateDisplayBrightness() {
    // Note: Actual brightness control depends on your display's backlight pin
    // This is a placeholder - you might need PWM control
    analogWrite(TFT_BACKLIGHT_PIN, encoder.displayBrightness); // If you have backlight control
}

// Get setting display text with current value
String getSettingDisplayText(SettingsOption setting) {
    switch (setting) {
        case SETTING_BRIGHTNESS:
            return "Brightness: " + String(encoder.displayBrightness);
        case SETTING_UNITS:
            return "Units: " + String(encoder.useMetricUnits ? "Metric" : "Imperial");
        case SETTING_BOOST_WARNING:
            return "Boost Warn: " + String(encoder.boostWarningThreshold, 1) + " PSI";
        case SETTING_TEMP_WARNING:
            return "Temp Warn: " + String(encoder.tempWarningThreshold, 1) + "¬∞C";
        case SETTING_EXPORT_DATA:
            return "Export Data";
        default:
            return "Unknown Setting";
    }
}

// Get setting name for serial output
const char* getSettingName(SettingsOption setting) {
    switch (setting) {
        case SETTING_BRIGHTNESS: return "Display Brightness";
        case SETTING_UNITS: return "Unit System";
        case SETTING_BOOST_WARNING: return "Boost Warning Threshold";
        case SETTING_TEMP_WARNING: return "Temperature Warning Threshold";
        case SETTING_EXPORT_DATA: return "Export Session Data";
        default: return "Unknown";
    }
}

// Draw menu indicator at top of screen
void drawMenuIndicator() {
    tft.setTextSize(1);
    tft.setTextColor(TFT_CYAN);
    
    // Draw menu tabs
    int tabWidth = 96; // 480/5 = 96 pixels per tab
    for (int i = 0; i < MENU_COUNT; i++) {
        uint16_t color = (i == encoder.currentMenu) ? TFT_YELLOW : TFT_DARKGREY;
        tft.fillRect(i * tabWidth, 0, tabWidth - 1, 20, color);
        
        tft.setTextColor(TFT_BLACK);
        tft.drawString(encoder.getMenuName((MenuState)i), i * tabWidth + 5, 5);
    }
}

// Placeholder functions for menu actions
void togglePerformanceMode() {
    Serial.println("üèÅ Performance mode toggled");
}

void refreshDiagnosticData() {
    Serial.println("üîß Diagnostic data refreshed");
}

void exportCurrentSession() {
    if (sdCard.initialized) {
        exportDrivingSession();
        Serial.println("üìä Session data exported");
    }
}